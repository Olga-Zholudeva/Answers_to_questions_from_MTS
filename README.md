# Answers_to_questions_from_MTS

## Python

1. Что такое *args и **kwargs в определении функции:

Это такой специальный синтаксис, который позволяет передать в функцию переменное количество аргументов. Удобно применять в случае, когда мы заранее не знаем какое количество аргументов будет передано в функцию. Или хотим иметь возможность передать любое количество агрументов.
- *args используется для передачи любого количества **неименованных** аргументов. Параметр args передаётся в тело функции в виде списка
- **kwargs используется для передачи любого количества именованных аргументов. Параметр kwargs передаётся в тело функции в виде словаря

2. Как выполняется обработка исключений:

Для обработки исключений существует конструкция try - except. Основная идея заключается в том, что в блок try помещается код, который необходимо выполнить. А в блоке except описываются действия, которые необходимо выполнить если выполнение кода из блока try завершилось ошибкой. При этом для каждого типа ошибки можно реализовать соответствующий код обработки в except. Также конструкцию можно дополнить блоком finally, в которой помещается код, который будет выполнен вне зависимости от наличия ошибок в блоке try.   

3. Чем кортеж отличается от списка:

Кортежи tuple, списки list представляют из себя контейнеры, в которых можно хранить упорядоченные коллекции из одного или нескольких элементов. Основная разница между ними состоит в том, что список — изменяемый тип, а кортеж — нет. Кортежи необходимо применять если нужно защитить данные от изменения, сэкономить память и иметь возможность использовать элементы коллекции в качестве ключей словаря. Списки применяют, когда необходима возможность менять коллекцию, в т.ч. добавлять/удалять элементы.

4. Решение представлено в файле palindrome.py

5. Решение представлено в файле converting_seconds.py

6. Решение представлено в файле list_comparison.py

## JavaScript

7. Чем отличаются операторы var, let, const:

Переменные, объявленные с помощью var:
- инициализируются как undefined
- могут иметь глобальную или локальную область видимости
- не имеют блочной области видимости
- могут обновляться и объявляться заново

Переменные, объявленные с помощью let:
- имеют блочную область видимости
- можно обновить, но нельзя объявить повторно

Переменные, объявленные с помощью const:
- имеют блочную область видимости
- нельзя обновлять и объявить повторно
- обязательна инициализация при объявлении

8. Как проверить наличие свойства/ключа у объекта:

- при помощи оператора in: позволяет проверить наличие свойства в объекте. Возвращает  true , если свойство найдено в указанном объекте
- при помощи метода hasOwnProperty(): проверяет содержит ли объект указанное свойство. Возвращает  true, если объект содержит указанное свойство, которое является прямым свойством этого объекта, а не унаследованным
- при помощи статического метода Reflect.has(): проверяет находится ли свойство в объекте
- при помощи метода Object.keys(): позволяет перебрать все свойства объекта и проверить каждый ключ

9. Какие циклы есть в JavaScript:

- for: используется для выполнения итераций определенное количество раз
- while: выполняет итерации, пока условие истинно
- do ... while: выполняет итерации, пока условие истинно, но проверка условия происходит после каждого выполнения

10. Какой код вызовет ошибку и почему?

а) let greeting = "say Hi";   
   greeting = "Say Hello insead";   

В данном коде ошибки не будет, т.к. переменная greeting объявлена при помощи let и поэтому ее значение может быть изменено

b) let greeting = "say Hi";   
   let greeting = "Say Hello insead";   

Этот код вызовет ошибку, т.к. переменная greeting объявлена при помощи let и поэтому не может быть объвлена повторно

c) let greeting = "say Hi";   
   if (true) {   
   let greeting = "Say Hello insead";   
   console.log(greeting);   
   }    
   console.log(greeting);   

Этот код не вызовет ошибку, т.к. переменная greeting, объявленная внутри блока при помощи let, будет иметь блочную видимость. При обращении к перменной внутри блока будет выведен результат Say Hello insead. А при обращении за пределами блока мы получим результат say Hi

11. Какой метод необходимо вызвать, чтобы действие по-умолчанию для какого-либо элемента DOM не выполнялась:

Для этой цели в обработчике события можно вызвать метод preventDefault() и отменить действие по-умолчанию.

## Oracle

12. Чем процедура отличается от функции:

- процедура не возвращает значение, функция возвращает значение;
- функция выполняет конкретную задачу, процедура может выполнять несколько задач;
- у функции возможен вызов из операторов SQL, для процедур такой вызов не осуществим;
- функции обычно используются для выполнения вычислений, процедуры используются для выполнения бизнес-логики;
- функция не выполняется независимо и должны быть частью исполняемого оператора. Процедура представляет собой исполняемый оператор, поэтому она может выполняться независимо.

13. В каком случае стоит использовать left join вместо join:

Использование LEFT JOIN вместо JOIN имеет смысл, когда необходимо получить все строки из левой (первой) таблицы вне зависимости от того, имеются ли соответствующие строки в правой (второй) таблице. Если не нашлось в правой, то напротив записи из левой будет NULL. Если использовать JOIN, то будут возвращены только строки, которые имеют совпадения в обеих таблицах.

14. Расставить операторы в порядке, в котором они должны писаться в запросе:

- SELECT
- FROM
- JOIN
- WHERE
- GROUP BY
- DISTINCT
- ORDER BY
- FETCH FIRST

15. Как можно найти необходимую таблицу, если известно только то, что в ней есть колонка с названием "personal_account_id":

Это можно сделать при помощи запроса:  
SELECT table_name 
FROM all_tab_columns 
WHERE column_name = 'personal_account_id';  

Запрос вернет все таблицы, в которых есть колонка с названием "personal_account_id"

16. Есть 3 таблицы с популярными именами, фамилиями и отчествами (name, surname, patronymic). Необходимо составить запрос, который выведет все возможные варианты сочетаний ФИО в одной таблице с тремя колонками по уменьшению популярности. В исходных таблицах есть колонки value и popularity 

SELECT name.value, surname.value, patronymic.value
FROM name
CROSS JOIN surname ON name.value = surname.value
CROSS JOIN patronymic ON surname.value = patronymic.value
ORDER BY (name.popularity + surname.popularity + patronymic.popularity) DESC;

17. Вызовет ли ошибку данный запрос: SELECT product_type, COUNT(*) FROM products:

Да, в запросе отсутствует оператор GROUP BY. Он необходим, чтобы сгруппировать данные по столбцу "product_type" перед применением функции COUNT(*)
Корректный запрос:

SELECT product_type, COUNT(*)  
FROM products   
GROUP BY product_type;   

## Тестовый проект

Проект выполнила во FLask, т.к. Django избыточен для этой задачи.
Проект находится в отдельном репозитории тут https://github.com/Olga-Zholudeva/Test_MTS